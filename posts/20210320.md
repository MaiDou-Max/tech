---
title: TypeScript使用（二）
date: 2021-03-20
description: 人生必有风险，因此令人着迷
category: TypeScript
tags:
  - TypeScript
  - 其他
---

Tips: 以前觉得写 TS 真的肺经，得先定义好多的类型非常麻烦，现在理解了 TS 是对类型的组合，应用好其实一句话就可以解决,
通过大约一周的学习 TS 里面有些比较难的概念进行了总结

### 一、可索引类型

```ts
// [{ id: 1, name: 'num1', age: 24 }, { id: 2, name: 'num2'}, { id: 3, name: 'num2', age: '25'}]
// [2, 3, 4, 5, 6, 7]
// ['2', 2, ]
// [2, 's', { id: 222, name: 2232, age: 2323 }]
export type JsonArray = {
  id: number;
  name: string | number;
  age?: number | string;
};
export type NumberArray = {
  [x: number]: number;
};
export type MixingArray = {
  [x: number]: number | string | JsonArray;
};
const jsonArray: JsonArray[] = [
  { id: 1, name: 'num1', age: 24 },
  { id: 2, name: 'num2' },
  { id: 3, name: 'num2', age: '25' },
];
const numberArray1: NumberArray = [2, 3, 4, 5, 6, 7];
const mixingArray: MixingArray = [2, 's', { id: 222, name: 2232, age: 2323 }];
```

总结： _可索引类型 --- 其实可以表示 string[] number[] key/value 形式的类型 ，当然类型定义时应该是越紧凑越好，索引签名必须是 number 或者 string 类型，而且数组必须是 number 类型，即使是 number 类型作为索引 javascript 也会将 number 转换成 string 去索引队象_

---

### 二、type（类型别名）和 interface（接口）

> - interface：
>   同名的 interface 自动聚合，也可以跟同名的 class 自动聚合
>   只能表示 object、class、function 类型
> - type:
>   不仅仅能够表示 object、class、function
>   不能重名（自然不存在同名聚合了），扩展已有的 type 需要创建新 type
>   支持复杂的类型操作
>   能用 interface 就用 interface 否则用 type

interface 和 type 都可以继承已有类型，语法上会有问题 （ tips: 团队分享的时候讲到 type extends type 或 type extends interface 之间不能通过 extends 实现， 需要用& ）

> 1、interface extends interface

```ts
interface Dog {
  name: string;
}
interface Animate extends Dog {
  age: number;
}
```

> 2、type extends type

```ts
type Dog = { name: string };
type Animate = Dog & { age: number };
```

> 3、interface extends type

```ts
type Dog = { name: string };
interface Animate extends Dog {
  age: number;
}
```

> 4、type extends interface

```ts
interface Dog {
  name: string;
}
type Animate = Dog & { age: number };
```

### 三、keyof 索引操作符

假设 T 是一个类型，那么 keyof T 产生的类型就是 T 的属性名称字符串字面量类型构成的联合类型(联合类型比较简单，和交叉类型对立相似)

```ts
interface Info {
  id: number;
  name: string;
  age: number;
  introduction;
}
type Ant = keyof Info; /* type Ant = "id"|"name"|"age"|"introduction"*/
```

**notice : 如果 T 是带有字符串索引的类型，那么 keyof T 是 string 或者 number 类型。 索引签名参数类型必须为 "string" 或 "number"**

### 四、泛型

    泛型是指在定义函数、接口或者类时，未指定其参数类型，只有在运行时传入才能确定。那么此时的参数类型就是一个变量，这里不多举例子

```ts
const test1: (arg: number) => number = (arg: number): number => arg;
const test2: (arg: string) => string = (arg: string): string => arg;
// 其实可以复用
const test = <T>(arg: T): T => arg;
```

总结：_泛型其实就是 JS 里的函数，通过参数接收一个类型返回一个新的类型_

### 五、infer

> - JS 声明变量的时候是 let num 其实声明了一个变量还没有赋值不确定是什么
> - TS 通过 infer 声明一个不确定的类型变量 infer R 就是声明一个类型变量 R
> - infer 理解起来比较抽象，最后查资料找案例大致理解下

```ts
interface StudentInfo {
  name: string;
  age: number;
  grade: number;
}

type ReturnParams<T> = T extends (student: infer P) => void ? P : T;
type createStudent = (student: StudentInfo) => void;
type params = ReturnParams<createStudent>;
```

总结： _首先是我们通过泛型定义一个 ReturnParams，当泛型接受的 T 是一个函数类型的时候我们用 inter 声明类型变量 P，将并不知道函数参数的类型是什么给保存起来然后返回，如果不是函数类型的话则返回 T_

###六、类型断言

> - 类型断言是我学的最快的，就像我们上来就会用 any 差不多
> - 类型断言 -----> 其实就是“纠正”ts 对类型的判断, 但是是不是纠正那就看自己了

```ts
const name = {};
name.chinaName = '苏忠宝';
name.english = 'suzhongbao'; /*TS会提示我们当前不存在这两个属性*/

type Name = {
  chinaName: string;
  englishName: string;
};
const name = {} as Name;
name.chinaName = '苏忠宝';
name.englishName = 'suzhonngbao';
// const name1 = <Name>{} 会和jsx混淆所以使用as关键字
```

总结：_所以慎用类型断言，除非你很清楚自己在干什么_

### 七、函数重载

什么是函数重载我们直接看个 🌰

```ts
declare function test(params: string): string;
declare function test(params: number): number; /*通过declare实现函数重载*/
const resStr1 = test('Hello World');
const resNum2 = test('123');

// ---这里我们申明了两次？！为什么我不能判断类型或者可选参数呢？所以做了下面的处理
declare function overload(info: Info | string, flag?: boolean): string;
/*这里并没有错误，但是违背了我们的想法*/
overload({ name: 'suzhongbao', age: 24 }, true);

/*实际是这样 我们是想如果传递info的Info类型 就不传flag, 如果传递info类型是string就传递flag，
但是TS并不知道我们想这样即使我们传了Info类型，也允许传递flag，但这不是我们想要的*/

declare function overload(info: Info): string;
declare function overload(info: string, flag: boolean): string;
const res = overload({ name: 'suzhongbao', age: 24 }, true);
/*这样TS就会检测出当你这里应该是string类型的参数*/
```

总结：_它的意义在于让你清晰的知道传入不同的参数得到不同的结果，如果传入的参数不同，但是得到相同类型的数据，那就不需要使用函数重载。_
