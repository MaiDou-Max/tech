---
title: 解决移动端IOS时间兼容性问题
date: 2021-07-26
description: 凡是过去，皆为序幕
category: Resolved Bugs
tags:
  - Resolved Bugs
  - 其他
---

Tips: 这两个月太懒了，没写博客，感觉除了 TS 也没什么写的，但是最近没怎么写 TS 所以也没遇到特别的坑，这次记录一个开发过程的一个兼容性的 bug

### 一、BUG 描述

1、前端 H5 项目使用的是 ant design mobile 的组件，具体是这个 DatePickerView 组件
2、巧了，这次也是请假审批，这次的业务是后端根据申请人的排班规则返回一个时间段，前端根据返回的时间段对空间的时间选择做限制，这是基本的业务场景
3、按照正常的开发结果已经基本完成，所以部署了前端服务，测试过程中发现 IOS 的手机不能选择到小时，安卓的手机可以
![](/images/bug.png)

---

### 二、分析 BUG 产生原因

> 1、首先还是老得思路确定接口是否有问题，然后查看代码逻辑， 代码块如下

```javascript
const returnDateType = useMemo(
  () => ({
    beginDate: beginDate,
    endDate: endDate,
  }),
  [beginDate, endDate]
);

const maxDate = useCallback(
  type => {
    if (!returnDateType[type]) {
      return new Date('2030/01/01 23:59:59');
    }
    const endYears = moment(returnDateType[type]).format('YYYY/MM/DD');
    const endHours = rangeTime[type].endHour.toString().padStart(2, '0');
    const endMinutes = rangeTime[type].endMinute.toString().padStart(2, '0');
    return new Date(`${endYears} ${endHours}:${endMinutes}:59`);
  },
  [returnDateType, rangeTime]
);

const minDate = useCallback(
  type => {
    if (!returnDateType[type]) {
      return new Date('2000/01/01 00:00:00');
    }
    const startYears = moment(returnDateType[type]).format('YYYY/MM/DD');
    const startHours = rangeTime[type].startHour.toString().padStart(2, '0');
    const startMinutes = rangeTime[type].startMinute.toString().padStart(2, '0');
    return new Date(`${startYears} ${startHours}:${startMinutes}:00`);
  },
  [rangeTime, returnDateType]
);

// JSX 部分
{
  ['begin', 'end'].map(type => (
    <DatePickerView
      key={type}
      maxDate={maxDate(`${type}Date`)}
      minDate={minDate(`${type}Date`)}
      mode="time"
      minuteStep={minuteStep}
      value={type === 'begin' ? beginTimeData : endTimeData}
      onChange={createSelectTimeHandler(type)}
    />
  ));
}
```

第一步发现后端接口肯定是没有问题的 { startHour: 18, startMinute: 0, endHour: 22, endMinute: 0 }, 后端格式是这样的，肯定没有问题，而且安卓没有问题，IOS 的手机都出不来日期，
可能是使用了 js 的高级语法 String.protoType.padStart 这个方法导致的，第一时间查看了 MDN 文档并排除了这样的问题，然后我们注释掉组件的两个 maxDate 和 minDate 两个属性发现正常，所以问题
出在了日期上，maxDate 和 minDate 是个函数并返回个 new Date 的类型

> 2、后端格式存在问题时 { startHour: 18, startMinute: 0, endHour: 2, endMinute: 0 }， 时间段是跨天这样的

这样发现我们的请假区间是个负的区间，也就是最小日期大于了最大日期，倒是没有区间可选随意只能制作我们自己的组件，ant design mobile 已经没有人维护了，所以做自己组件的好处就体现了

### 三、解决问题的代码

问题原因就是 IOS 只识别特定的日期格式

```javascript
// IOS不识别的日期格式
const newDate = moment(date).format('YYYY-MM-DD');

// IOS识别的日期格式
const newDate = moment(date).format('YYYY/MM/DD');
```

PS: 其实这次问题比较小，但是出了好多 bug，总结下遇到的问题，对日期时间这个一定要非常敏感， 尤其是一些临界值的问题，一定多注意，一旦控制不好就会出现 bug，还有一些时区，一个月有没有 31 天，
例如：

```javascript
/*司领工领试用期截止日期修正的问题，问题是如果用户导入一条这样的数据， 
入职日期是2020-05-31 日  试用期月数1个月 试用截止日期2020-04-30 这样后端会计算是否增加， 
多少月 多少天 算出差值， 但是前端修正的时候会默认回显计算当前的试用期截止日期，
计算的时候如果前端先减去月份 导致4月没有31号会变成30日最终减去一天变成29日，这样和用户添加的试用期截止日期差一天，
如果前端先减去一天在减去一个月就计算的正确， 所以这里建议计算逻辑挪到后端计算，或者对前端的控件进行优化
*/
```

| 基础日期：4.30 | 加 1 个月       | 加 1 天        | 结果 |
| -------------- | --------------- | -------------- | ---- |
| 先加月         | 5.30(加 1 个月) | 5.31(加 1 天)  | 5.31 |
| 先加日         | 5.1(加 1 天)    | 6.1(加 1 个月) | 6.1  |
